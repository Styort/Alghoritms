// Дан массив интервалов, где intervals[i] = [start, end], объедините все пересекающиеся интервалы
// и верните массив непересекающихся интервалов.
//
// Вход: [[2,6], [1,3], [8,10], [15,18]]
// Выход: [[1,6], [8,10], [15,18]]

// Сложность решения по скорости: O(n*log(n))
// Сложность решения по памяти: O(n)
// В целом можно улучшить алгоритм, сделав in-place решение без выделения доп. массива
// Но данное решение в целом и так эффективное
List<List<int>> mergeIntervals(List<List<int>> input) {
  print('Input: $input');

  if (input.isEmpty) return input;

  // Сперва отсортируем входящий массив по start интервалам
  // Пример: [[1,3], [2,6], [8,10], [15,18]]
  input.sort((a, b) => a[0].compareTo(b[0]));

  // Добавляем первый интервал и далее идём со второго
  var merged = List<List<int>>.empty(growable: true);
  merged.add(input.first);

  for (int i = 1; i < input.length; i++) {
    // Если следующий интервал входит в последний, то изменяем конец последнего интервала
    if (input[i][0] <= merged.last[1]) {
      merged.last[1] = input[i][1];
    } else {
      // Иначе, просто добавляем новое значение в массив
      merged.add(input[i]);
    }
  }

  print('Output: $merged');

  return merged;
}
